---
title : 코어자바스크립트_01.데이터타입 
date : 2024-12-11 22:33:00 +09:00
categories : [js]
tags : [js, study] 
---
![image](https://github.com/user-attachments/assets/99796d0c-76c8-4d88-b3a8-22641a8edc94)
# 01 데이터타입
목표 : 기본형과 참조형 타입이 서로 다르게 동작하는 이유를 이해한다
## 1-1. 데이터 타입의 종류 
|데이터 타입|종류|차이|
|------|---|---|
|기본형|값이 담긴 주솟값 복제|number, string, boolean, null, undifined, Symbol ...|
|참조형|주솟값의 묶음의 주솟값 복제|object, Array, Function, Date, RegExp, Map, WeakMap, Set...|

## 1-2. 데이터 타입에 관한 배경지식
### 1-2-1. 메모리와 데이터
|단위|범위|구분|
|---|---|---|
|bit|0 또는 1이 표현되는 메모리 조각|식별자|
|byte|8bit|메모리 주솟값|
### 1-2-2. 식별자와 변수
|주소|뜻|
|---|---|
|데이터|변할 수 있는 수|
|식별자/변수명|어떤 데이터를 식별하는데 사용하는 이름|

## 1-3. 변수 선언과 데이터 할당 
### 1-3-1. 변수 선언
변수 : 변경 가능한 데이터가 담길 수 있는 공간
### 1-3-2. 데이터 할당
```
[주소]1003={
   식별자 : a
   값 : @5005
}, ...
[주소]5005={
   값 : "abcde"
}
```
식별자와 변수를 서로 다른 메모리에 저장하고, 두개의 값을 주소로 연결한다. <br>
변수가 바뀔때마다 새로운 주소에 데이터를 할당하고, 식별자는 새로운 데이터를 할당한 메모리 주소를 기억한다.
기존 변수는 연결된 식별자가 없으면 가비지컬렉터의 수거 대상이 된다.

## 1-4. 기본형 데이터와 참조형 데이터
|종류|구분|
|---|---|
|변수|바꿀 수 있음|
|상수|바꿀 수 없음|
### 1-4-1. 불변값
> 기본형 데이터 : 숫자, 문자열, boolean, null, undefined, Symbol...

변수가 변경될때마다 메모리에 새로운 데이터를 할당하고, 해당 데이터의 주소를 변수가 기억하기 때문에, 최초 메모리에 저장 됐던 데이터는 변하지 않는다. <br>
기존 데이터는 변하지 않고, 새로 만들기 때문에 불변하다.
### 1-4-2. 가변값
> 모든 참조형 데이터가 가변값은 아니다. 하지만 대부분의 참조형 데이터는 가변 설질을 가지고 있다.

```
var obj1={ a:1, b:'bbb' }

[주소]1003={식별자 : obj1, 값 : @5005}, ...
[주소]5003={식별자 : a, 값 : @5003}
[주소]5004={식별자 : b, 값 : @5004}
[주소]5005={값 : @7103~}, ...
[주소]7103={식별자 : a, 값 : @5003}
[주소]7104={식별자 : b, 값 : @5004} ...
```
변수,식별자만 있던 기본형과 달리, 객체를 선언한 변수가 추가로 더 존재한다. <br>
객체의 값은 주소로 기억하고, 그 주소는 값들의 주소를 기억하고있다. 주소가 주소를 기억하는 형태로 주소는 언제든지 변경 될 수 있다.
### 1-4-3. 변수 복사 비교
> "기본형은 값을 복사하고 참조형은 주솟값을 복사한다"
> => 기본형은 주솟값을 복사하는 과정이 한번만 이뤄지고, 참조현은 한 단계를 더 거치게된다.

## 1-5. 불변 객체
### 1-5-1. 불변 객체를 만드는 간단한 방법
객체는 가변하다. 이는 객체를 저장하는 메모리는 객체이름은 키 주소를 기억하고, 키주소는 변수의 주소를 기억하고, 변수는 데이터를 기억하기 때문이다. 그렇기 때문에 객체가 기억하는 키 주소의 변수의주소는 언제든지 가능하다.
불변객체는 왜 필요할까? 데이터의 변경을 추적하기 위해서 필요하다. 
예시로 유저가 닉네임을 변경했을때 우리는 유저에게 알림을 보내기로 했다. 알림을 보내기 위해서는 유저가 닉네임을 변경했는지를 알아야한다. 닉네임 변경을 알기 위해서는 이전 닉네임과 변경 닉네임을 비교하고 동일하지 않을때 변경을 알 수 있다.
그렇다면 이전 닉네임과 변경 닉네임을 모두 저장 해야한다. 여기서 이전 닉네임은 불변객체로 만들어 변경된닉네임 값으로 들어가지 않게 해야한다.
### 1-5-2. 얕은 복사와 깊은 복사
얕은복사 : 아래단계의 값만 복사

주소값만 복사하여, 원본을 바꾸면 사본이 바뀌고, 사본을 바꾸면 원본이 바뀔 가능성이 있음

깊은복사 : 내부의 모든 값들을 하나하나 전부 찾아서 복사

⇒ 가변한 객체는 복사 시에 주솟값만 복사하기 때문에 원본을 불편하게 지키기 위해서는 깊은 복사가 필요하다. 깊은 복사는 객체 내부를 돌면서 불변한 기본형 단위로 복사하여 데이터의 주소까지 복사하는 것이다.
## 1-6. undefined와 null
undifined는 자바스크립트 엔진이 자동으로 부여하기 때문에, 비어있음을 명시적으로 작성할때에는 null을 할당하자

배열을 비어있는 값을 순회하지 않는다.

```jsx
var arr = []
arr1.length = 3
console.log(arr1) // [empty x3]
```

### undifined

자바스크립트 엔진이 자동으로 부여하거나, 명시적으로 지정할때 출력

엔진이 부여하는 경우는 값의 이름조차 없는경우지만, 명시적으로 지정해줄 경우는 이름도 있고 값도 undifined로 지정한 것이다.

```
var a ; // undifined
let b ; // 빈값
const c ; // 빈값
=>  var는 undifined로 초기화 되지만, let,const는 아무 값도 없는 상태로 초기화된다.
```

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할때
2. 객체 내부의 존재하지 않은 프로퍼티에 접근하려고 할때
3. return문이 없거나  호출되지 않는 함수의 실행결과

### null

비어있음을 명시적으로 사용할때 사용

```
var n = null
console.log(typeof n); // object
console.log(n == undefined); // ture
console.log(n === undefined); // false
```
#### 참고자료
